#include <misc.h>
#include <params.h>

SUBROUTINE tend_lin
!------------------------------------------------------------------------------------------------
! Purpose: Compute the tendence of P, T, U, V ( Linear(adaption) part )
! Author : ZhangHe
! Completed : 2005.9.1
! Update    : 2006.2.22, Zhanghe, revise to linear part
!             2007.4.23, ZhangHe, 1) delete dumb parameter 'NCTDCB'
!                                 2) change sub. name from 'ptuvtend1' to 'tend_lin'
!                                 3) change 'LADDSS' to 'NADDSS'
!             2007.10.11, ZhangHe, modify the calculation of TOO0
!             2008.4.7, ZhangHe, 1) move statement of Kstd to module flexib
!                                2) modify use of kappa
!             2008.5, WuJianping, parallel version
!             2008.6.11, ZhangHe, available for both serial & parallel
!             2011.05.03, ZhangHe, let deltac = 0 if adiabatic run
!------------------------------------------------------------------------------------------------
   use shr_kind_mod, only: r8 => shr_kind_r8
   use IAP_grid,  only: NX, NY, NM, NL, NZ, JB, JE, IB, IE, period,ex,ie1
   use Dyn_const 
   use stdatm,    only: DPALIB, NA, CB, CBB, PSB, deltac, H0B, TB     !zhh 2007.4.23
   use IAP_prog,  only: PT, TT, UT, VT, WST, Psa, U, WS, WPV, PLY, GHI,     &
                        Pstar1, Pstar2, GZsm, deltap, P, V
   use tendency,  only: DPsa, DT, DU, DV, SU, SV, ST, NADDSS
   use physconst, only: b0, CAPA
   use mathconst, only: ZERO, HALF, ONE, TWO, FOURTH
   use flexib,    only:  b1, b21, b22, c10, kappa, kappa2, IBCFFT, Kstd,testnum
   use pmgrid,    only: beglatdyn, endlatdyn, loc_JB, loc_JE,beglev,endlev,iam,plon,myid_y,&
                    endlevp,npr_z,npr_y,beglatdynex,endlatdynex,plat,plev,strip3zaty,myid_z
   use stdatm,    only: P00
#if ( defined SPMD )
   use mod_comm, only: mp_send3d, mp_recv3d,mp_send3d_2, mp_recv3d_2
   use spmd_dyn          , only:  comm_z,lreq,rreq,zdist
   use mpishorthand, only: mpir8
   use parutilitiesmodule, only: parcollective,sumop,pargatherreal
#endif


   IMPLICIT NONE
   include 'mpif.h'
#include <comctl.h>   ! adiabatic
!----------------------------------Local workspace-----------------------------------------------
   real(r8) :: WW(NX,NY)                    ! wjp  2008.5
   real(r8) :: DGH(NX,NL,beglatdyn:endlatdyn)                ! d(GHI) 
   real(r8) :: GHI1(NX,NZ,beglatdyn:endlatdyn)                ! d(GHI) 

!   real(r8) :: TT1(NX,NL,beglatdyn:endlatdyn)                ! d(GHI) 
   real(r8) :: TT1(IB:IE,beglatdyn:endlatdyn,2,NL)              ! jjr 2012-07-16
   real(r8) :: TT0(IB:IE,beglatdyn:endlatdyn,2,beglev:endlev)   ! jjr 2012-07-16 
   real(r8) :: PXW(NX,beglatdyn:endlatdyn), PXW2(NX,beglatdyn:endlatdyn)      ! auxiliary variables
   real(r8) :: PYP(NX,beglatdyn:endlatdyn), PYM(NX,beglatdyn:endlatdyn)       ! auxiliary variables
   real(r8) :: rhos(NX,beglatdynex:endlatdynex)                  ! surface density of atmosphere
   real(r8) :: pDrho(NX,beglatdynex:endlatdynex)                 ! pDrho = P'sa / rhos
   real(r8) :: DpDrX(NX,beglatdynex:endlatdynex), DpDrY(NX,beglatdynex:endlatdynex)   ! zonal & meridional gradient of pDrho
   real(r8) :: DIVX, DIVY, DIV(IB:IE,NL,beglatdyn:endlatdyn)    ! divergence of (PT*VT)
   real(r8) :: D1(NL), DWK(NL) , DPS1       ! auxiliary variables
   real(r8) :: D2(NL),D3(NL) !jjr
   real(r8) :: DsaX, DsaY, Dsa(NX,NY)       ! Dsa = DsaX + DsaY , diffusion of P'sa
   real(r8) :: DsaY1(NX), DPsa1
   real(r8) :: WK5                          ! WK5 = 1 / PT 
   real(r8) :: DXP0, DXP1, DXP2, DXP3       ! zonal difference of pes**
   real(r8) :: DYP0, DYP2                   ! meridional difference of pes**
   real(r8) :: OO1, OO2X, OO2Y, TOO0        ! terms of DTT/Dt
   real(r8) :: O1P, O2P, OOP, TOOP          ! terms of DTT/Dt at polar
   real(r8) :: DTTP                         ! tendency of TT at polar
   real(r8) :: PV1(NX)                      ! divergence of (PT¡¤VT) at polar
   real(r8) :: W1(NL+1), WPV1(NL),W11             ! auxiliary variables
   real(r8) :: WSK(NL+1), D1K, DSK,WSK1               ! auxiliary variables
   real(r8) :: OPCT0, OPCT2, OPCT3, OPCT4, OPCT5   ! auxiliary variables
   real(r8) :: OUXAXP, OUXAXP2, OYAYP, OYVS ! auxiliary variables
   real(r8) :: GH0, GH1, GH2, GH3, GH4      ! the average value of GHI
   real(r8) :: PY1, PY2, PY(NX,NL,NY)       ! meridional component of pressure-gradient force
   real(r8) :: PX1, PX2, PX(NX,NL,NY)       ! zonal component of pressure-gradient force
   real(r8) :: FS0, FS1, FS2, FS3           ! Coriolis parameter 
   real(r8) :: fstar0, fstar1               ! Coriolis parameter at polar
   real(r8) :: FSU, FSV                     ! work terms of Coriolis
   real(r8) :: WPK, WPJ, WPI                ! weight as pressure
   real(r8) :: time_begin, time_end
   integer  :: KPK, KPI,src,dest,src1,dest1
   integer  :: KK, I, J, K ,num1                 ! loop index
   integer:: tmp1,recs(npr_z),disps(npr_z),ierr  !test
   real(r8),allocatable:: sbuf(:,:)
   real(r8),allocatable:: sbuf1(:,:)
   real(r8),allocatable::rbuf(:,:)
   real(r8),allocatable::rbuf1(:,:)

!----------------------------------------------------------------------------------------------

!     *******************************************************************
!     *******************************************************************
!     **************        COMPUTE DPsa & DT        ********************
!     *******************************************************************
!     *******************************************************************

!------------------- COMPUTE FACTORS RELATED TO (I,J) ONLY ----------------------
!
        call t_startf('tend_lin')
#if (defined SPMD)
!   call mpi_move_left(PT(1,endlatdyn), PT(1,beglatdyn-1),NX)
!   call mpi_move_right( PT(1,beglatdyn), PT(1,endlatdyn+1),NX)
!jjr src dest,right
        call t_startf('comm')
        call t_startf('comm1')
        num1=endlev-beglev+1
        allocate(sbuf(NX,2*num1+4))
        allocate(rbuf(NX,2*num1+4))
        sbuf(:,1)=pt(:,endlatdyn)
        sbuf(:,2)=ksa(:,endlatdyn)
        sbuf(:,3)=p(:,endlatdyn)
        sbuf(:,4)=Pstar2(:,endlatdyn)
       do kk=beglev,endlev
        sbuf(:,5+kk-beglev)=vt(:,kk,endlatdyn)
        sbuf(:,5+num1+kk-beglev)=v(:,kk,endlatdyn)
       end do
        call mpi_move_left(sbuf,rbuf,NX*(2*num1+4))
      
        allocate(sbuf1(NX,4*num1+5))
        allocate(rbuf1(NX,4*num1+5))
        sbuf1(:,1)=pt(:,beglatdyn)
        sbuf1(:,2)=ksa(:,beglatdyn)
        sbuf1(:,3)=p(:,beglatdyn)
        sbuf1(:,4)=Pstar2(:,beglatdyn)
        sbuf1(:,5)=Pstar1(:,beglatdyn)

       do kk=beglev,endlev
        sbuf1(:,6+kk-beglev)=tt(:,kk,beglatdyn)
        sbuf1(:,6+num1+kk-beglev)=deltap(:,kk,beglatdyn)
        sbuf1(:,6+2*num1+kk-beglev)=ut(:,kk,beglatdyn)
        sbuf1(:,6+3*num1+kk-beglev)=u(:,kk,beglatdyn)
       end do

      call mpi_w_a(2,lreq) 
        call mpi_move_right(sbuf1,rbuf1,NX*(4*num1+5))
       if(myid_y.ne.(npr_y-1)) then
       pt(:,beglatdynex)=rbuf(:,1)
       ksa(:,beglatdynex)=rbuf(:,2)
       p(:,beglatdynex)=rbuf(:,3)
       Pstar2(:,beglatdynex)=rbuf(:,4)
       do kk=beglev,endlev
        vt(:,kk,beglatdynex)=rbuf(:,5+kk-beglev)
        v(:,kk,beglatdynex)=rbuf(:,5+num1+kk-beglev)
       end do
        end if
      call mpi_w_a(2,rreq)
       if(myid_y.ne.0) then
       pt(:,endlatdynex)=rbuf1(:,1)
       endif
     src = iam-1
      dest  = iam+1
      if ( mod(iam,npr_y) == 0 ) src = -1
      if ( mod(iam+1,npr_y) == 0 ) dest = -1
      src1 = iam+1
      dest1  = iam-1
      if ( mod(iam,npr_y) == 0 ) dest1 = -1
      if ( mod(iam+1,npr_y) == 0 ) src1 = -1

      call t_stopf('comm1')
      call t_stopf('comm')



#endif
   DO J = beglatdyn, endlatdyn
      IF (J.GE.JB.AND.J.LE.JE) THEN
         DO I = 1 ,NX
            PYP(I,J)   = RUPH(J) * (PT(I,J+1)+PT(I,J)) !RUPH(J) = sin¦È(j+1/2) / (2*a*¦¤¦È*sin¦È(j))
            PYM(I,J)   = RUMH(J) * (PT(I,J)+PT(I,J-1)) !RUMH(J) = sin¦È(j-1/2) / (2*a*¦¤¦È*sin¦È(j))
            rhos(i,j)  = 1 / H0B(i,j)
            pDrho(i,j) = Psa(i,j) / rhos(i,j)
!!if(beglev.eq.7.and.j.eq.179) print*,'test DT2',PT(i,180),PT(i,181),i
         ENDDO
         DO I = IB,IE
            PXW(I,J)   = OUXH(J) * (PT(I,J)   + PT(I-1,J)) !OUXH(J) = 1 / (2*a*¦¤¦Ë*sin¦È(j))
            PXW2(I,J)  = OUXH(J) * (PT(I+1,J) + PT(I-2,J))            
            DpDrX(I,J) = OUXH(J) * (pDrho(I+1,J) - pDrho(I-1,J))                         !(*5)			
         ENDDO
         call period( PXW  (1,J) )                 
         call period( PXW2 (1,J) )
         call period( DpDrX(1,J) )
      ELSE
         DO I = 1 ,NX
            PYP(I,J)   = ZERO
            PYM(I,J)   = ZERO
            rhos(i,j)  = ZERO
            pDrho(i,j) = ZERO
            PXW(I,J)   = ZERO
            PXW2(I,J)  = ZERO         
            DpDrX(I,J) = ZERO		
         ENDDO
      ENDIF
   ENDDO


#if (defined SPMD)
!   call mpi_move_left(pDrho(1,endlatdyn), pDrho(1,beglatdyn-1),NX)
!   call mpi_move_right( pDrho(1,beglatdyn), pDrho(1,endlatdyn+1),NX)
        call t_startf('comm')
      call mp_send3d( dest, src, NX,NY,1,                     &
                      1, NX, beglatdynex, endlatdynex,1,1,       &
                      1, NX, beglatdyn, beglatdyn,1,1,  pDrho )
       if(myid_y.ne.0) then
       ksa(:,endlatdynex)=rbuf1(:,2)
       p(:,endlatdynex)=rbuf1(:,3)
       Pstar2(:,endlatdynex)=rbuf1(:,4)
       Pstar1(:,endlatdynex)=rbuf1(:,5)
      end if
      call mp_recv3d( src, NX,  NY,1,                            &
                      1, NX, beglatdynex, endlatdynex,1,1,       &
                      1, NX, endlatdynex, endlatdynex,1,1,pDrho )
      call mp_send3d( dest1, src1, NX, NY,1,                     &
                      1, NX, beglatdynex, endlatdynex,1,1,       &
                      1, NX, endlatdyn, endlatdyn, 1, 1, pDrho )
       if(myid_y.ne.0) then
       do kk=beglev,endlev
        tt(:,kk,endlatdynex)=rbuf1(:,6+kk-beglev)
        deltap(:,kk,endlatdynex)=rbuf1(:,6+num1+kk-beglev)
       end do
      endif

      call mp_recv3d( src1, NX,  NY,1,                             &
                      1, NX, beglatdynex, endlatdynex,1,1,       &
                      1, NX, beglatdynex, beglatdynex,1,1, pDrho )
       call t_stopf('comm')
#endif
   DpDrY=0.
   DO J = loc_JB, loc_JE
      DO I = 1, NX
         DpDrY(i,j) = RDLATH*(pDrho(i,j+1) - pDrho(i,j-1))
      END DO
   END DO

!     COMPUTE    DTT/DT

#if (defined SPMD)
!   call mpi_move_left(    VT(1,1,endlatdyn),     VT(1,1,beglatdyn-1),NX*NL)
         call t_startf('comm')

      call mp_send3d_2( dest, src, NX,NY,1,                     &
                      1, NX, beglatdynex, endlatdynex,1,1,       &
                      1, NX, beglatdyn, beglatdyn,1,1,  DPDRY,rhos )
       if(myid_y.ne.0) then
       do kk=beglev,endlev
        ut(:,kk,endlatdynex)=rbuf1(:,6+2*num1+kk-beglev)
        u(:,kk,endlatdynex)=rbuf1(:,6+3*num1+kk-beglev)
       end do
      endif

      call mp_recv3d_2( src, NX,  NY,1,                            &
                      1, NX, beglatdynex, endlatdynex,1,1,       &
                      1, NX, endlatdynex, endlatdynex,1,1,dpdry,rhos)

 
      call mp_send3d_2( dest1, src1, NX, NY,1,                     &
                      1, NX, beglatdynex, endlatdynex,1,1,       &
                      1, NX, endlatdyn, endlatdyn, 1, 1, dpdry,rhos )
      call mp_recv3d_2( src1, NX,  NY,1,                             &
                      1, NX, beglatdynex, endlatdynex,1,1,       &
                      1, NX, beglatdynex, beglatdynex,1,1, dpdry,rhos )
       call t_stopf('comm')
!   call mpi_move_left(  rhos(1,  endlatdyn),   rhos(1,  beglatdyn-1),NX)
!   call mpi_move_right(   rhos(1,  beglatdyn),   rhos(1,  endlatdyn+1),NX)
!   call mpi_move_left(   ksa(1,  endlatdyn),    ksa(1,  beglatdyn-1),NX)
!   call mpi_move_right(    ksa(1,  beglatdyn),    ksa(1,  endlatdyn+1),NX)
!   call mpi_move_left( DpDrY(1,  endlatdyn),  DpDrY(1,  beglatdyn-1),NX)
!   call mpi_move_right(  DpDrY(1,  beglatdyn),  DpDrY(1,  endlatdyn+1),NX)
!   call mpi_move_left(     P(1,  endlatdyn),      P(1,  beglatdyn-1),NX)
!   call mpi_move_right(      P(1,  beglatdyn),      P(1,  endlatdyn+1),NX)
!   call mpi_move_left(     V(1,1,endlatdyn),      V(1,1,beglatdyn-1),NX*NL)
!   call mpi_move_left(Pstar2(1,  endlatdyn), Pstar2(1,  beglatdyn-1),NX)
!   call mpi_move_right( Pstar2(1,  beglatdyn), Pstar2(1,  endlatdyn+1),NX)
    if(npr_z.gt.1) then
      DIV=0.
      DO K=1,NL
          D2(K)=0.
          D3(K)=0.
      ENDDO
     endif

#endif
   DO J = beglatdyn, endlatdyn

      IF (J.GE.JB.AND.J.LE.JE) THEN
!jjr         DO I = IB, IE
! -------------------------------- COMPUTE DIVERGENCES & THEIR SUMS --------------------------
        DO K = beglev ,endlev
         DO I = IB, IE
!jjr               DIVX = alpha(J)*(PXW(I+1,J) *UT(I+1,K,J) - PXW(I,J)*UT(I  ,K,J))   &
               DIV(I,K,J) = alpha(J)*(PXW(I+1,J) *UT(I+1,K,J) - PXW(I,J)*UT(I  ,K,J))   &
!jjr                    + betaw(J)*(PXW2(I+2,J)*UT(I+2,K,J) - PXW2(I-1,J)*UT(I-1,K,J))/3.0 !(4.21)
                    + betaw(J)*(PXW2(I+2,J)*UT(I+2,K,J) - PXW2(I-1,J)*UT(I-1,K,J))/3.0 &!(4.21)
!jjr               DIVY = (PYP(I,J)*VT(I,K,J)-PYM(I,J)*VT(I,K,J-1))                        !(4.22)
               + (PYP(I,J)*VT(I,K,J)-PYM(I,J)*VT(I,K,J-1))                        !(4.22)
!jjr               DIV(I,K,J)  = DIVX + DIVY             
!!if(k.eq.7.and.j.eq.179) print*,'test DT01',DIVY,PYP(i,j),PYM(i,j),&
!! DIV(i,k,j),i,iam,testnum

!jjr               D1(K)  = DIVX + DIVY
!jjr               DWK(K) = D1(K) * DSIG(K)
            ENDDO
        ENDDO
      ELSE IF(J.EQ.1) THEN         ! at north polar
         DO K = beglev ,endlev
            DO I = IB,IE
               PV1(I) = (PT(IB,1)+PT(I,JB))*VT(I ,K,1)    !PT(IB,1)=PT(I,1)       !(4.20)-(2)
            ENDDO
            D1K  = ZERO
            DO I = IB,IE
               D1K = D1K  + PV1(I)
            ENDDO
            D2(K)  = D1K  *  RDLATI     ! RDLATI = 2 / (IM*a*d(sita))
          ENDDO
          if(npr_z.gt.1) then
#if (defined SPMD)
             call parcollective(comm_z,sumop,NL,D2)
#endif
          end if

      ELSE                        ! J = NY  South polar
         DO K = beglev ,endlev
            DO I = IB,IE
               PV1(I) = (PT(IB,NY)+PT(I,JE))*VT(I,K,JE)                               !(4.20)-(2)
            ENDDO
            D1K = ZERO
            DO I = IB,IE
               D1K = D1K + PV1(I)
            ENDDO
            D3(K)  = -D1K  *  RDLATI
         ENDDO
         if(npr_z.gt.1) then
#if (defined SPMD)
            call parcollective(comm_z,sumop,NL,D3)
#endif
         end if

      ENDIF

    ENDDO

!!    if (npr_z .gt. 1) then
!!#if (defined SPMD)
!!       call parcollective(comm_z,sumop,NL,D2)
!!        call parcollective(comm_z,sumop,NL,D3)
!!       call parcollective3d( comm_z, sumop, IE-IB+1,NL, endlatdyn-beglatdyn+1,DIV)
!!       print*,'test tend_lin1'
!!#endif
!!    endif

!jjr   DIV=DIV*10.E23 
!   DIV=AINT(DIV,8)
!   DIV=DIV/10.E23
#if (defined SPMD)
   if(myid_z.eq.0) then
#endif
     do k=beglev,endlev
      do j=beglatdyn,endlatdyn
            do i=IB,IE
               TT1(i,j,1,k)=DIV(i,k,j)
               TT1(i,j,2,k)=TT(i,k,j)
            end do
         enddo
      end do
#if (defined SPMD)
   endif
#endif
!
   if(npr_z.gt.1) then
#if (defined SPMD)
      do j=beglatdyn,endlatdyn
     do k=beglev,endlev
            do i=IB,IE
               TT0(i,j,1,k)=DIV(i,k,j)
               TT0(i,j,2,k)=TT(i,k,j)
            end do
         enddo
      end do
!jjr  TT0(IB:IE,beglatdyn:endlatdyn,beglev:endlev)=DIV(IB:IE,beglev:endlev,beglatdyn:endlatdyn)

       call t_startf('parg')
       call t_startf('parg1')
      disps(1)=0
      num1=(endlatdyn-beglatdyn+1)*(IE-IB+1)*2
      do i=1,npr_z
      recs(i)=zdist(i)*num1
      if(i.ne.npr_z) disps(i+1)=disps(i)+recs(i)
      end do
      num1=zdist(myid_z+1)*num1
      call mpi_allgatherv(TT0,num1,mpir8,TT1,recs,disps,mpir8,comm_z,ierr)
!jjr      call pargatherreal(comm_z, 0, TT0, strip3zaty, TT1)
      call t_stopf('parg1')
!     call pargatherreal(comm_z,0,DIV,strip3zatypt,TT1(:,:,:,2))
!jjr      call mpibcast (TT1,plon*NL*(endlatdyn-beglatdyn+1),mpir8,0,comm_z)
!       call parcollective( comm_z, sumop, plon,NL, endlatdyn-beglatdyn+1,TT1)
#endif
   endif
!
          call t_stopf('parg')
     DO J = beglatdyn, endlatdyn

      IF (J.GE.JB.AND.J.LE.JE) THEN
         DO I = IB, IE
            DsaX       = OUXH(j)*(rhos(i+1,j)*ksa(i+1,j)*DpDrX(i+1,j)             &
!jjr            Dsa(i,j)       = OUXH(j)*(rhos(i+1,j)*ksa(i+1,j)*DpDrX(i+1,j)             &
                       -          rhos(i-1,j)*ksa(i-1,j)*DpDrX(i-1,j))                  !(4.23)
!                       -          rhos(i-1,j)*ksa(i-1,j)*DpDrX(i-1,j))          &        !(4.23)
            DsaY       = RUPPH(j)*(rhos(i,j+1)*ksa(i,j+1)*DpDrY(i,j+1))           &
!             + RUPPH(j)*(rhos(i,j+1)*ksa(i,j+1)*DpDrY(i,j+1))           &
                       - RUMMH(j)*(rhos(i,j-1)*ksa(i,j-1)*DpDrY(i,j-1))                 !(4.23)
          Dsa(i,j)   = (DsaX + DsaY)
         ENDDO
         DO I = IB, IE

! -------------------------------- COMPUTE DIVERGENCES & THEIR SUMS --------------------------
            DO K = 1 ,NL
!!               D1(K)  = DIV(I,K,J)
               D1(K)  = TT1(I,j,1,k)
               DWK(K) = D1(K) * DSIG(K)

            ENDDO

            DPS1 = -DWK(1)                 ! for Psa'
            DO K = 2 ,NL
               DPS1 = DPS1 - DWK(K)        ! sums for K
            ENDDO
!
! ******************************  compute Dsa *******************************
!            DsaX       = OUXH(j)*(rhos(i+1,j)*ksa(i+1,j)*DpDrX(i+1,j)             &
!                       -          rhos(i-1,j)*ksa(i-1,j)*DpDrX(i-1,j))                  !(4.23)
!            DsaY       = RUPPH(j)*(rhos(i,j+1)*ksa(i,j+1)*DpDrY(i,j+1))           &
!                       - RUMMH(j)*(rhos(i,j-1)*ksa(i,j-1)*DpDrY(i,j-1))                 !(4.23)
!            Dsa(i,j)   = (DsaX + DsaY) 	   
			  
!-------------------------------- COMPUTE DP'sa/DT & D(SIGMA)/DT -------------------------------
            DPsa(i,j)  = P00*(DPS1) + kappa*Dsa(i,j)       
!!debug  if(beglev.eq.7.and.j.eq.180) print*,'test DPSA',DSAY,rhos(i,j+1),rhos(i,j-1),&
!! i,iam,testnum,ksa(i,j+1),ksa(i,j-1),Dpdry(i,j+1),DpDry(i,j-1)
 
!---------------------------------------------------------
            IF ( abs(DPS1).GT.0.001 ) THEN
               PRINT*, 'At sub. tend_lin, IN THE INNER AREA: DP=',DPS1, 'i=',I, 'j=', J
               PRINT*, 'DIV(i,26,j)=', D1(26), 'DIVX=', DIVX, 'DIVY=', DIVY
            ENDIF
!---------------------------------------------------------
            WK5 = ONE / PT(I,J)
            DPS1 = DPsa(i,j)
            DO K = 1 ,NM      ! NM = NL - 1
!               DWK(K)  = WK5*(kappa*(DPS1-Dsa(i,j))/P00 + D1(K))*DSIG(K)                 !(4.31)
               DWK(K)  = WK5*((DPS1-kappa*Dsa(i,j))/P00 + D1(K))*DSIG(K)                 !(4.31)
            ENDDO
            WSK1  = ZERO
            DO K = 2 ,NL
               WSK1     = WSK1 - DWK(K-1)
               WSK(k)=WSK1
            end do
             WSK(NZ)=0.
            do k=beglev,endlev+1
               WST(I,K,J)    = WSK(k)      
               WS(I,K,J)     = WST(I,K,J)/PT(I,J)  !WS = d(¦Ò)/dt; WS(1)=WS(NZ)=0
            ENDDO

         ENDDO       ! end i = IB,IE
!!!!

         call period( DPsa   (1,J) )
         DO K  = beglev ,endlev+1
            call period( WS (1,K,J) )
            call period( WST(1,K,J) )
         ENDDO
!------------------------ Compute P-surface vertical velocity (WPV) ---------------------------
         DO K = beglev ,endlev
            DO I = IB,IE
!               DIVX = OUXQ(J) * (U(I,K,J) + U(I+1,K,J)) * (P(I+1,J) - P(I-1,J))     
!               DIVX = OUXQ(J) * (U(I,K,J) + U(I+1,K,J)) * (P(I+1,J) - P(I-1,J))     
!               DIVY = RDLATQ  * (V(I,K,J) + V(I,K,J-1)) * (P(I,J+1) - P(I,J-1))
!               DIVY = RDLATQ  * (V(I,K,J) + V(I,K,J-1)) * (P(I,J+1) - P(I,J-1))
               WPV(I,K,J) = HALF * (WS(I,K+1,J) + WS(I,K,J)) * P(I,J)               &
                          + SIGL(K) * (DPsa(i,j) + OUXQ(J) * (U(I,K,J) + U(I+1,K,J)) * &
               (P(I+1,J) - P(I-1,J)) + RDLATQ  * (V(I,K,J) + V(I,K,J-1)) * (P(I,J+1) - P(I,J-1)))                     ! P124 (8)

            ENDDO
            call period( WPV(1,K,J) )               		 
         ENDDO

!
!------------------ COMPUTE DTT/DT FOR J [JB,JE]  &  I [IB,IE]  &  K [1,NL] ---------------------
         DO K = beglev ,endlev
            DO I = IB,IE
               DXP0 = Pstar2(I  ,J) - Pstar2(I-1,J)
               DXP1 = Pstar2(I+1,J) - Pstar2(I,J)
               DXP2 = Pstar2(I  ,J) - Pstar2(I-3,J)
               DXP3 = Pstar2(I+3,J) - Pstar2(I,J)
               DYP0 = Pstar2(I,J+1) - Pstar2(I,J)
               DYP2 = Pstar2(I,  J) - Pstar2(I,J-1)
!
               OO1  = HALF*(WST(I,K+1,J) + WST(I,K,J)) / SIGL(K)                       &
                    - (DIV(I,K,J)/PT(I,J) + TWO*SGH(K)*(WST(I,K+1,J) - WST(I,K,J)))         !(4.19)
               OO2X = OUXH(J)/Pstar1(I,J)*(alpha(J)*(DXP1*UT(I+1,K,J)+DXP0*UT(I,K,J))  &
                                      +betaw(J)/3.0*(DXP3*UT(I+2,K,J)+DXP2*UT(I-1,K,J)))  !(4.18)
               OO2Y = (RUPH(J)*DYP0*VT(I,K,J) + RUMH(J)*DYP2*VT(I,K,J-1)) / Pstar1(I,J)   !(4.17)  
               TOO0 = (1. - deltap(I,K,J)) * ( b0 * (1. + deltac(I,K,J))               & 
                    + Kstd*CAPA*TT(I,K,J)/PT(I,J) ) * (b1*OO1 + b22*OO2X + b21*OO2Y)  
               DT(I,K,J)  = TOO0                       ! (3.3)
!!debug if(k.eq.7.and.j.eq.179) print*,'test DT00',DT(i,7,179),VT(i,7,178),WST(i,7,179),&
!! DIV(i,k,j),i,iam,testnum

            ENDDO
            call period( DT(1,K,J) )
         ENDDO
!------------------------------- FOR THE POLAR POINTS -----------------------------------
      ELSE IF(J.EQ.1) THEN         ! at north polar
         W11 = ZERO
! -------------------------COMPUTE DIVERGENCE AT NORTH POLE------------------------------
         DPS1 = ZERO
         DO K = 1 ,NL
            DPS1   = DPS1 - D2(K)*DSIG(K)                 ! for Psa'
         ENDDO
!
!ZRT---------------------------------------------------------
         IF (DPS1.GT.0.1) THEN
            PRINT*,'IN NORTH POLAR:    DP=',DPS1,I,J
            PRINT*,'DIV=',D2
         ENDIF
!ZRT---------------------------------------------------------
         DO I = IB,IE
            DsaY1(I) = rhos(I,2) * ksa(I,2) * DpDrY(I,2)                               !(4.23')
         ENDDO
         DSK = ZERO
         DO I = IB,IE
            DSK = DSK  + DsaY1(I)
         ENDDO
         DSK = DSK * RDLATI2
!----------------------COMPUTE DP/DT & D(SIGMA)/DT AT NORTH POLE------------------------
         DPsa1 = P00*(DPS1) + kappa*DSK
			
         DO K = 1 ,NM               ! NM = NL - 1
!            DWK(K)    = (kappa*(DPsa1-DSK)/P00 + D1(K))*DSIG(K)/PT(IB,1)
            DWK(K)    = ((DPsa1-kappa*DSK)/P00 + D2(K))*DSIG(K)/PT(IB,1)
         ENDDO
         DO K = 2 ,NL
            W11     = W11 - DWK(K-1)  !W1(1) = ZERO
            W1(k)=W11
         ENDDO
         DO I = 1 ,NX
            DPsa(I,1) = DPsa1
         ENDDO
            W1(NZ)=0.

         DO K = beglev ,endlev+1
            DO I = 1 ,NX
               WST(I,K,1)  = W1(K)
               WS (I,K,1)  = WST(I,K,1)/PT(I,1)
            ENDDO
         ENDDO
         DO K = beglev ,endlev
            WPV1 (K) = HALF * (WS(IB,K+1,1) + WS(IB,K,1)) * P(IB,1)                  &
                     + SIGL(K) * DPsa(IB,1)          ! DIV(Pes) = 0
            DO I = 1 ,NX
               WPV(I,K,1) = WPV1 (K)
            ENDDO
         ENDDO

!---------------------------------COMPUTE DTT/DT AT NORTH POLE------------------------------------
         DO K = beglev ,endlev
!           COMPUTE HORIZONTAL & VERTICAL ADVECTION OF TT
            O2P    = ZERO
            DO I   = IB,IE
               O2P = O2P + (Pstar2(I,JB)-Pstar2(IB,1))*VT(I ,K,1) / Pstar1(IB,1)       !(4.17)-(2)
            ENDDO
            O2P    = RDLATI * O2P
            O1P    = HALF*(WST(IB,K+1,1) + WST(IB,K,1)) / SIGL(K)         &
                   - (D2(K)/PT(IB,1) + TWO*SGH(K)*(WST(IB,K+1,1) - WST(IB,K,1)))         !(4.19)
            TOOP = (1. - deltap(IB,K,1)) * ( b0 * (1. + deltac(IB,K,1))               & 
                 + Kstd*CAPA*TT(IB,K,1)/PT(IB,1) ) * (b1*O1P + b21*O2P)                                                         
            DTTP   = TOOP
            DO I = 1 ,NX
               DT(I,K,1) = DTTP
            ENDDO
         ENDDO
!  -------------------------------- FOR THE SOUTH POLAR POINTS --------------------------------------
      ELSE                        ! J = NY  South polar
         W1(1) = ZERO
!  COMPUTE DIVERGENCE AT SOUTH POLE
         DPS1  = ZERO
         DO K = 1 ,NL
            DPS1   = DPS1 - D3(K)*DSIG(K)
         ENDDO

!ZRT---------------------------------------------------------
         IF (DPS1.GT.0.1) THEN
            PRINT*,'IN THE SOUTHEN POLAR:    DP=',DPS1,I,J
            PRINT*,'DIV=',D3
         ENDIF
!ZRT---------------------------------------------------------
         DO I = IB,IE
            DsaY1(I) = rhos(I,JE) * ksa(I,JE) * DpDrY(I,JE)                             !(4.23')
         ENDDO
         DSK = ZERO
         DO I = IB,IE
            DSK = DSK  + DsaY1(I)
         ENDDO
         DSK = -DSK * RDLATI2
!-------------------- COMPUTE DP/DT & D(SIGMA)/DT & WPV AT SOUTH POLE ------------------------
         DPsa1 = P00*(DPS1) + kappa*DSK
!
         DO K = 1 ,NM               ! NM = NL - 1
!            DWK(K)    = (kappa*(DPsa1-DSK)/P00 + D1(K))*DSIG(K)/PT(IB,NY)
            DWK(K)    = ((DPsa1-kappa*DSK)/P00 + D3(K))*DSIG(K)/PT(IB,NY)
         ENDDO
         DO K = 2 ,NL
            W1(K)     = W1(K-1) - DWK(K-1)  !W1(1) = ZERO
         ENDDO
         DO I = 1 ,NX
            DPsa(I,NY)    = DPsa1
         ENDDO
         DO K = beglev ,endlev+1
            DO I = 1 ,NX
               WST(I,K,NY)  = W1(K)
               WS (I,K,NY)  = WST(I,K,NY)/PT(I,NY)
            ENDDO
         ENDDO
         DO K = beglev ,endlev
            WPV1 (K) = HALF * (WS(IB,K+1,NY) + WS(IB,K,NY)) * P(IB,NY)                 &
                     + SIGL(K) * DPsa(IB,NY)
            DO I = 1 ,NX
               WPV(I,K,NY) = WPV1 (K)
            ENDDO
         ENDDO
!
!-------------------------------- COMPUTE DTT/DT AT south POLES -------------------------------------
         DO K = beglev ,endlev
!           COMPUTE HORIZONTAL & VERTICAL ADVECTION OF TT
            O2P    = ZERO
            DO I   = IB,IE
               O2P = O2P + (Pstar2(IB,NY)-Pstar2(IB,JE))*VT(I,K,JE) / Pstar1(IB,NY)    !(4.17)-(3)
            ENDDO
            O2P    = RDLATI * O2P
            O1P    = HALF*(WST(IB,K+1,NY) + WST(IB,K,NY)) / SIGL(K)         &
                   - (D3(K)/PT(IB,NY) + TWO*SGH(K)*(WST(IB,K+1,NY) - WST(IB,K,NY)))      !(4.19)
            TOOP = (1. - deltap(IB,K,NY)) * ( b0 * (1. + deltac(IB,K,NY))               & 
                 + Kstd*CAPA*TT(IB,K,NY)/PT(IB,NY) ) * (b1*O1P + b21*O2P)                                                         
            DTTP   = TOOP

            DO I = 1 ,NX
               DT(I,K,NY) = DTTP
            ENDDO
         ENDDO
      ENDIF
!
      IF ( NADDSS.EQ.+1 ) THEN     !zhh 2007.4.23
!         ADD SOURCE & SINK
         DO K = beglev,endlev 
            DO I = 1 ,NX
               DT(I,K,J) = DT(I,K,J) + ST(I,K,J)
!!debug if(k.eq.7.and.j.eq.179) print*,'test DT0',DT(i,7,179),ST(i,7,179),&
!! i,iam,testnum

            ENDDO
         ENDDO
      ENDIF
!if((plat-j+1).eq.91.and.beglev.eq.1) print*,'test dt',dt(50+ex,1,j)
   ENDDO  !(end for DO J = 1 ,NY)

!       testnum=testnum+1
!       if(testnum.eq.2) then
!       tmp1 = 0
!         do while(tmp1.eq.0)
!          call sleep(2)
!       enddo
!       endif


!     HIGH-MID LAT FILTER  FOR DPsa/DT & DTT/DT
!!   call cpu_time( time_begin )
!!do i=1,nx
!! do j=beglatdyn,endlatdyn
!!if(testnum.eq.1.and.j.eq.179) print*,'test DPsa1',DPsa(i,179),&
!! i,iam
!! end do
!!end do

   WW(:,beglatdyn:endlatdyn)=DPsa(:,beglatdyn:endlatdyn)   !zhh 2008.6.16
   CALL FILT2D( WW,0,1,IBCFFT )		   !zhh 2008.6.16
   DPsa(:,beglatdyn:endlatdyn)=WW(:,beglatdyn:endlatdyn)

!!do i=1,nx
!! do j=beglatdyn,endlatdyn
!!if(testnum.eq.1.and.j.eq.179) print*,'test DPsa',DPsa(i,179),&
!! i,iam
!! end do
!!end do

   DO KK = beglev,endlev
!!do i=1,nx
!! do j=beglatdyn,endlatdyn
!!if(kk.eq.7.and.j.eq.179) print*,'test DT1',DT(i,7,179),&
!! i,kk,iam,testnum
!! end do
!!end do

      WW(:,beglatdyn:endlatdyn)=DT(:,KK,beglatdyn:endlatdyn)
      CALL FILT2D( WW,0,1,IBCFFT )   !OK
      DT(:,KK,beglatdyn:endlatdyn)=WW(:,beglatdyn:endlatdyn)
!!do i=1,nx
!! do j=beglatdyn,endlatdyn
!!if(kk.eq.7.and.j.eq.179) print*,'test DT',DT(i,7,179),&
!! i,kk,iam,testnum
!! end do
!!end do

   ENDDO

!!   call cpu_time( time_end )
!!   print*, 'run time of FILT2D-PT was ', time_end - time_begin, 'sec'
!
!     *******************************************************************
!     *******************************************************************
!     ****************         COMPUTE DU & DV        *******************
!     *******************************************************************
!     *******************************************************************
!
!******************* update PLY & deltac for next time step **********************
!     TT=TT*10.E10
!     TT=AINT(TT,8)
!     TT=TT/10.E10

 ! if(npr_z.gt.1) then
!#if (defined SPMD)
!   do j=beglatdyn,endlatdyn
!     do k=1,nl
!         do i=1,nx
!         TT1(i,k,j)=0.
!         end do
!     end do
!   end do
!#endif
!  endif
!   do j=beglatdyn,endlatdyn
!      do k=beglev,endlev
!          do i=1,nx
!          TT1(i,k,j)=TT(i,k,j)
!          end do
!      enddo
!   end do
!   if(npr_z.gt.1) then
!#if (defined SPMD)

!       call parcollective3d( comm_z, sumop, NX,NL, endlatdyn-beglatdyn+1,TT1)
!!      print*,'tend_lin2',b0,dpalib
!       testnum=testnum+1
!       if(testnum.eq.2) then
!       tmp1 = 0
!         do while(tmp1.eq.0)
!          call sleep(2)
!       enddo
!       endif

!#endif
!   endif
!!   do j=beglatdyn,endlatdyn
!!       do i=1,nx
!!        if(j.eq.179.and.beglev.le.7.and.endlev.ge.7) print*,'test jjjjj',TT(i,7,j),i,j,&
!!       testnum,iam
!!       do k=beglev,endlev+1
!!  if(j.eq.179.and.k.eq.7) print*,'test ghi',TT1(i,7,j),&
!!            i,k,j,testnum,iam
!!       end do
!!       end do
!!  end do

!#if (defined SPMD)
!    if(myid_z.eq.0) then
!#endif
!      do j=beglatdyn,endlatdyn
!      do k=beglev,endlev
!          do i=IB,IE
!          TT1(i,j,k)=TT(i,k,j)
!          end do
!      enddo
!   end do
!#if (defined SPMD)
!   endif
!#endif
!   if(npr_z.gt.1) then
!#if (defined SPMD)
!  do j=beglatdyn,endlatdyn
!      do k=beglev,endlev
!          do i=IB,IE
!          TT0(i,j,k)=TT(i,k,j)
!          end do
!      enddo
!   end do

       
!     call t_startf('parg')
!     call t_startf('parg1')
!      call pargatherreal(comm_z, 0, TT0, strip3zaty, TT1)
!       call t_stopf('parg1')
!
!!     call pargatherreal(comm_z,0,DIV,strip3zatypt,TT1(:,:,:,2))
!       call mpibcast (TT1,plon*NL*(endlatdyn-beglatdyn+1),mpir8,0,comm_z)
!       call parcollective( comm_z, sumop, plon,NL, endlatdyn-beglatdyn+1,TT1)
!#endif
!   endif
!
!       call t_stopf('parg')
   DO J = beglatdyn,endlatdyn
      DO K = 1 ,NL
         DO I = 1 ,NX
            PLY(I,K,J) = P(I,J)*SIGL(K) + PMTOP
!jjr            deltap(I,K,J) = PMTOP / PLY (I,K,J) !jjr
         ENDDO
      ENDDO
      DO I = 1 ,NX
         PLY(I,NZ,J)  = P(I,J) + PMTOP
      ENDDO
      DO K = beglev ,endlev
         DO I = 1 ,NX
            WPK  = PLY(I,K,J) / DPALIB  ! DPALIB = 0.5
            KPK  = WPK + 1.0E-4
            WPJ  = WPK - KPK
            WPI  = ONE - WPJ
            KPI  = KPK + 1
            IF (KPI.GT.NA) THEN   ! NA = PEALIB/DPALIB = 2320
               PRINT*,'************************THERE IS AN ERROR IN CBB***************'     
               PRINT*,'PLY(I,K,J)=',PLY(I,K,J),'I,K,J=',I,K,J
               PRINT*,'P(I,J)=',P(I,J)
               PRINT*, 'stop: tend_lin'
               stop 'tend_lin'
            ENDIF
            CB (I,K,J)    = WPI*CBB(KPK) + WPJ*CBB(KPI)
            if (adiabatic) then
               deltac(I,K,J) = 0.0
            else
               deltac(I,K,J) = CB(I,K,J) * CB(I,K,J) / (b0 * b0) - 1.0
            end if
         ENDDO
      ENDDO
!********************************** Compute GHI *******************************************
      DO I = 1 ,NX
         GHI1(I,NZ,J) = H0B(I,J) * (PLY(I,NZ,J) - PSB(I,J)) + kappa2 * GZsm(I,J)    !P113 (4)    
!          H0B £½ Rd * TMSA(PSB)/PSB,   TMSA: temperature of standard atmosphere 
      ENDDO
      DO K = 1 ,NL
         DO I = IB ,IE			                                                                       
            DGH(I,K,J) = b0 * TT1(I,J,2,K) * (1.-deltap(I,K,J)) / (PT(I,J)*SIGL(K))*DSIG(K)
			                                                                       !  (3.5)
         ENDDO
      ENDDO
      DO K = NL,1 ,-1
         DO I = IB ,IE
            GHI1(I,K,J) = GHI1(I,K+1,J) + DGH(I,K,J)
         ENDDO
      ENDDO
     DO K=beglev,endlev+1
         DO I=IB,IE
           GHI(I,K,J)=GHI1(I,K,J)
         ENDDO
      call period(GHI(1,k,j))
     ENDDO

   ENDDO
!       if(testnum.eq.2) then
!       tmp1 = 0
!         do while(tmp1.eq.0)
!          call sleep(2)
!       enddo
!       endif

!
#if (defined SPMD)
          call t_startf('comm')
      call mp_send3d( dest, src, NX,NZ, NY,                     &
                      1, NX,beglev,endlev+1, beglatdynex, endlatdynex,       &
                      1, NX, beglev,endlev+1,beglatdyn, beglatdyn,  GHI )
      call mp_recv3d( src, NX,NZ,  NY,                             &
                      1, NX,beglev,endlev+1, beglatdynex, endlatdynex,       &
                      1, NX,beglev,endlev+1, endlatdynex, endlatdynex, GHI )

!   call mpi_move_right(    PT(1,  beglatdyn),     PT(1,  endlatdyn+1),NX)
!jjr   call mpi_move_right(    TT(1,1,beglatdyn),     TT(1,1,endlatdyn+1),NX*NL)
!jjr   call mpi_move_right(deltap(1,1,beglatdyn), deltap(1,1,endlatdyn+1),NX*NL)
!jjr   call mpi_move_right(Pstar1(1,  beglatdyn), Pstar1(1,  endlatdyn+1),NX)
!jjr   call mpi_move_right(   GHI(1,1,beglatdyn),    GHI(1,1,endlatdyn+1),NX*NZ)
!jjr   call mpi_move_right(     U(1,1,beglatdyn),      U(1,1,endlatdyn+1),NX*NL)
!jjr   call mpi_move_right(    FF(    beglatdyn),     FF(    endlatdyn+1),1)
!jjr   call mpi_move_right(   CUR(    beglatdyn),    CUR(    endlatdyn+1),1)
!jjr   call mpi_move_left(   VT(1,1,endlatdyn),     VT(1,1,beglatdyn-1),NX*NL)
!jjr   call mpi_move_right(    UT(1,1,beglatdyn),     UT(1,1,endlatdyn+1),NX*NL)
        deallocate(sbuf)
        deallocate(sbuf1)
        deallocate(rbuf)
        deallocate(rbuf1)
         call t_stopf('comm')
#endif
!
!       testnum=testnum+1
!       if(testnum.eq.2) then
!       tmp1 = 0
!         do while(tmp1.eq.0)
!          call sleep(2)
!       enddo
!       endif
     call t_startf('fft')
   DO J  = beglatdyn, endlatdyn
! --------------------- COMPUTE PY AT THE NORTH POLAR (J=1) -------------------------------
!
      IF (J.EQ.1) THEN
         DO K = beglev ,endlev
            DO I = IB,IE
               DYP0  = Pstar2(I,JB) - Pstar2(IB,1)
               OYAYP = RDLATQ*(PT(IB,1)+PT(I,JB))                       
               OPCT0 = b0 * TT(IB,K,1) * (1. - deltap(IB,K,1)) / Pstar1(IB,1)
               OPCT3 = b0 * TT(I,K,JB) * (1. - deltap(I,K,JB)) / Pstar1(I,JB)
!
               PY1   = OYAYP * ( (GHI(I,K+1,JB) + GHI(I,K,JB))    &       
                     -           (GHI(IB,K+1,1) + GHI(IB,K,1)) )          ! (4.4)
               PY2   = RDLATH * ( OPCT0 + OPCT3 ) * DYP0                  ! (4.5)
               PY(I,K,1) = b1*PY1 + b21*PY2
               PX(I,K,1) = ZERO
            ENDDO
            call period( PX(1,K,J) )
            call period( PY(1,K,J) )               
         ENDDO
      ELSE IF(J.LE.JE) THEN
!
!     COMPUTE PX & PY FROM J=JB TO J=JE
!
         DO K = beglev ,endlev
            DO I = IB,IE
               DXP0  = Pstar2(I  ,J) - Pstar2(I-1,J)
               DXP1  = Pstar2(I+1,J) - Pstar2(I-2,J)
               OUXAXP = OUXQ(J) * ( PT(I  ,J) + PT(I-1,J) )
               OUXAXP2= OUXQ(J) * ( PT(I+1,J) + PT(I-2,J) )
               DYP0  = Pstar2(I,J+1) - Pstar2(I,J)
               OYAYP = RDLATQ  * ( PT(I,J) + PT(I,J+1) )
!
               OPCT0 = b0 * TT(I  ,K,J) * (1. - deltap(I  ,K,J)) / Pstar1(I  ,J)
               OPCT2 = b0 * TT(I-1,K,J) * (1. - deltap(I-1,K,J)) / Pstar1(I-1,J)
               OPCT3 = b0 * TT(I,K,J+1) * (1. - deltap(I,K,J+1)) / Pstar1(I,J+1)
               OPCT4 = b0 * TT(I+1,K,J) * (1. - deltap(I+1,K,J)) / Pstar1(I+1,J)
               OPCT5 = b0 * TT(I-2,K,J) * (1. - deltap(I-2,K,J)) / Pstar1(I-2,J)
               GH0   = GHI(I  ,K+1,J) + GHI(I  ,K,J)
               GH1   = GHI(I-1,K+1,J) + GHI(I-1,K,J)
               GH2   = GHI(I+1,K+1,J) + GHI(I+1,K,J)
               GH3   = GHI(I-2,K+1,J) + GHI(I-2,K,J)
               GH4   = GHI(I,K+1,J+1) + GHI(I,K,J+1)

               PX1   = alpha(J) * OUXAXP  * ( GH0 - GH1 )                      &
                     + betaw(J) * OUXAXP2 * ( GH2 - GH3 ) / 3.0                     ! (4.10)
               PX2   = alpha(J) * OUXH(J) * ( OPCT0 + OPCT2 ) * DXP0           &
                     + betaw(J) * OUXH(J) * ( OPCT4 + OPCT5 ) * DXP1 / 3.0          ! (4.11)
               PY1   = OYAYP  * ( GH4 - GH0)                                        ! (4.4 )
               PY2   = RDLATH * ( OPCT0 + OPCT3 ) * DYP0                            ! (4.5 )
               PX(I,K,J)  = b1*PX1 + b22*PX2
               PY(I,K,J)  = b1*PY1 + b21*PY2
            ENDDO
            call period( PX(1,K,J) )
            call period( PY(1,K,J) )
         ENDDO
      ELSE        ! AT THE SOUTH POLAR (J=NY)
         DO K = beglev ,endlev
            DO I = 1 ,NX
               PX(I,K,J)  = ZERO
               PY(I,K,J)  = ZERO
            ENDDO
         ENDDO
      ENDIF
!
!         COMPUTE DV/DT AT J=1
!
      IF (J.EQ.1) THEN    !AT THE NORTH POLAR  
         DO K = beglev ,endlev
            DO I = IB,IE
               fstar0 = FF(JB)+CUR(JB)  * U(I  ,K,JB)
               fstar1 = FF(JB)+CUR(JB)  * U(I+1,K,JB)
               FSU = FOURTH * ( fstar0 * UT(I,K,JB) + fstar1 * UT(I+1,K,JB) )
               DV(I,K,1) = - PY(I,K,1) + c10*FSU       ! (3.1)	
               DU(I,K,1) = ZERO
            ENDDO
            call period( DU(1,K,J) )
            call period( DV(1,K,J) )
         ENDDO
!
      ELSE IF(J.LE.JE) THEN
! ----------------- COMPUTE DU/DT & DV/DT FOR J [JB,JE] & I [IB,IE] & K [1,NL] ------------------
!         
         DO K = beglev ,endlev
            DO I = IB,IE
               FS0  = FF(J  ) + CUR(J  ) * U(I  ,K,J)                             ! P101 (18)
               FS1  = FF(J  ) + CUR(J  ) * U(I+1,K,J)
               FS2  = FF(J+1) + CUR(J+1) * U(I  ,K,J+1)
               FS3  = FF(J+1) + CUR(J+1) * U(I+1,K,J+1)
! 
               FSV  = FS0  * ( RUPD(J) * (VT(I,K,  J) + VT(I-1,K,  J))                      &
                    +          RUMD(J) * (VT(I,K,J-1) + VT(I-1,K,J-1)) )            ! (4.12)
               FSU  = FOURTH * ( FS0 * UT(I,K,J)   + FS1 * UT(I+1,K,J)                      &
                    +            FS2 * UT(I,K,J+1) + FS3 * UT(I+1,K,J+1) )          ! (4.6)
               DU(I,K,J) = - PX(I,K,J) - c10*FSV      ! (3.2)    
               DV(I,K,J) = - PY(I,K,J) + c10*FSU      ! (3.1)   
            ENDDO
            call period( DU(1,K,J) )
            call period( DV(1,K,J) )
         ENDDO
!
      ELSE   !  J = NY  AT THE SOUTH POLAR
         DO K = beglev ,endlev
            DO I = 1 ,NX
               DU(I,K,J)= ZERO
               DV(I,K,J)= ZERO
            ENDDO
         ENDDO
      ENDIF
!
!!      print*, 'NADDSS =', NADDSS
!  ADD SOURCE & SINK if necessary
      IF ( NADDSS.EQ.+1 ) THEN
         DO K = beglev ,endlev
            DO I = 1 ,NX
!=============================== zhh =====================================
               IF (abs(DU(I,K,J)) > 1E1 .OR. abs(DV(I,K,J)) > 1E1 .or.      &
                   abs(SU(I,K,J)) > 1E1 .OR. abs(SV(I,K,J)) > 1E1) THEN
                  print*, 'DU(',I,K,J,') =', DU(I,K,J)
                  print*, 'DV(',I,K,J,') =', DV(I,K,J),i,k,j
                  print*, 'SU(',I,K,J,') =', SU(I,K,J)
                  print*, 'SV(',I,K,J,') =', SV(I,K,J)
                  print*, 'tend_lin--1'
                  stop
               ENDIF
!============================ 2007.8.5 ====================================
               DU(I,K,J) = DU(I,K,J) + SU(I,K,J)
               DV(I,K,J) = DV(I,K,J) + SV(I,K,J)
            ENDDO
         ENDDO
      ENDIF
   ENDDO        !end J = 1,NY
!
!     HIGH-MID LAT FILTER  FOR DU/DT & DV/DT

!!   call cpu_time( time_begin )
   DO KK = beglev,endlev
!      WW(:,beglatdyn:endlatdyn)=DU(:,KK,beglatdyn:endlatdyn)
      WW(:,beglatdyn:endlatdyn)=DU(:,kk,beglatdyn:endlatdyn)
      CALL FILT2D( WW,1,1,IBCFFT )	
      DU(:,kk,beglatdyn:endlatdyn)=WW(:,beglatdyn:endlatdyn)
!         
      WW(:,beglatdyn:endlatdyn)=DV(:,kk,beglatdyn:endlatdyn)
      CALL FILT2D( WW,1,2,IBCFFT )	
      DV(:,kk,beglatdyn:endlatdyn)=WW(:,beglatdyn:endlatdyn)
   ENDDO
         call t_stopf('fft')
         call t_stopf('tend_lin')
!!   call cpu_time( time_end )
!!   print*, 'run time of FILT2D-UV was ', time_end - time_begin, 'sec'
!
   RETURN
END
